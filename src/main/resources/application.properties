application.name=@project.artifactId@
build.version=@project.version@
spring.redis.host=${REDIS_HOST}
spring.redis.password=${REDIS_PASSWORD}
spring.redis.port=${REDIS_PORT}
spring.redis.ssl=${REDIS_SSL_ENABLED}
azurestorage.queues.transactionexpiration.name=${TRANSACTIONS_EXPIRATION_QUEUE_NAME}
azurestorage.queues.transactionsrefund.name=${TRANSACTIONS_REFUND_QUEUE_NAME}
azurestorage.queues.transactionrefundretry.name=${TRANSACTIONS_REFUND_RETRY_QUEUE_NAME}
azurestorage.queues.transactionclosepayment.name=${TRANSACTIONS_CLOSE_PAYMENT_QUEUE_NAME}
azurestorage.queues.transactionclosepaymentretry.name=${TRANSACTIONS_CLOSE_PAYMENT_RETRY_QUEUE_NAME}
azurestorage.queues.transactionnotificationretry.name=${TRANSACTIONS_NOTIFICATIONS_RETRY_QUEUE_NAME}
azurestorage.queues.transactionnotification.name=${TRANSACTIONS_NOTIFICATIONS_QUEUE_NAME}
azurestorage.queues.transactionauthorizationrequested.name=${TRANSACTIONS_AUTHORIZATION_REQUESTED_QUEUE_NAME}
azurestorage.queues.transactionauthorizationoutcomewaiting.name=${TRANSACTIONS_AUTHORIZATION_OUTCOME_WAITING_QUEUE_NAME}
azurestorage.transient.connectionstring=${QUEUE_TRANSIENT_CONNECTION_STRING}
azurestorage.queues.deadletter.name=${TRANSACTIONS_DEAD_LETTER_QUEUE_NAME}
azurestorage.deadletter.connectionstring=${QUEUE_DEADLETTER_CONNECTION_STRING}
azurestorage.queues.transientQueues.ttlSeconds=${TRANSIENT_QUEUES_TTL_SECONDS:604800}
azurestorage.queues.deadLetterQueue.ttlSeconds=${DEAD_LETTER_QUEUE_TTL_SECONDS:-1}

spring.jackson.serialization.write-dates-as-timestamps=false
spring.jackson.deserialization.fail-on-unknown-properties=true

spring.cloud.azure.storage.queue.account-key=${ECOMMERCE_STORAGE_TRANSIENT_QUEUE_KEY}
spring.cloud.azure.storage.queue.account-name=${ECOMMERCE_STORAGE_TRANSIENT_QUEUE_ACCOUNT_NAME}
spring.cloud.azure.storage.queue.endpoint=${ECOMMERCE_STORAGE_TRANSIENT_QUEUE_ENDPOINT}

nodo.uri=${NODO_URI}
nodo.readTimeout=${NODO_READ_TIMEOUT}
nodo.connectionTimeout=${NODO_CONNECTION_TIMEOUT}
nodo.ecommerce.clientId=${NODO_ECOMMERCE_CLIENT_ID}

spring.data.mongodb.uri=mongodb://${MONGO_USERNAME}:${MONGO_PASSWORD}@${MONGO_HOST}:${MONGO_PORT}/?ssl=${MONGO_SSL_ENABLED}&readPreference=primaryPreferred&maxStalenessSeconds=90&minPoolSize=${MONGO_MIN_POOL_SIZE}&maxPoolSize=${MONGO_MAX_POOL_SIZE}&maxIdleTimeMS=${MONGO_MAX_IDLE_TIMEOUT_MS}&connectTimeoutMS=${MONGO_CONNECTION_TIMEOUT_MS}&socketTimeoutMS=${MONGO_SOCKET_TIMEOUT_MS}&serverSelectionTimeoutMS=${MONGO_SERVER_SELECTION_TIMEOUT_MS}&waitQueueTimeoutMS=${MONGO_WAITING_QUEUE_MS}&heartbeatFrequencyMS=${MONGO_HEARTBEAT_FREQUENCY_MS}
spring.data.mongodb.database=ecommerce
paymentTransactionsGateway.uri=${PAYMENT_TRANSACTIONS_GATEWAY_URI}/
paymentTransactionsGateway.readTimeout=${PAYMENT_TRANSACTIONS_GATEWAY_READ_TIMEOUT}
paymentTransactionsGateway.connectionTimeout=${PAYMENT_TRANSACTIONS_GATEWAY_CONNECTION_TIMEOUT}
paymentTransactionsGateway.apiKey=${PAYMENT_TRANSACTIONS_GATEWAY_API_KEY}

server.port=9000

management.endpoint.health.probes.enabled=true

refundRetry.eventOffsetSeconds=${REFUND_RETRY_EVENT_BASE_INTERVAL_SECONDS}
refundRetry.maxAttempts=${REFUND_RETRY_EVENT_MAX_ATTEMPTS}

closePaymentRetry.eventOffsetSeconds=${CLOSE_PAYMENT_RETRY_EVENT_BASE_INTERVAL_SECONDS}
closePaymentRetry.maxAttempts=${CLOSE_PAYMENT_RETRY_EVENT_MAX_ATTEMPTS}
closePaymentRetry.paymentTokenValidityTimeOffset=${CLOSE_PAYMENT_RETRY_EVENT_PAYMENT_TOKEN_VALIDITY_TIME_OFFSET:10}

transactionAuthorizationOutcomeWaiting.eventOffsetSeconds=${AUTHORIZATION_OUTCOME_WAITING_EVENT_BASE_INTERVAL_SECONDS}
transactionAuthorizationOutcomeWaiting.maxAttempts=${AUTHORIZATION_OUTCOME_WAITING_EVENT_MAX_ATTEMPTS}
transactionAuthorizationOutcomeWaiting.paymentTokenValidityTimeOffsetSeconds=${AUTHORIZATION_OUTCOME_WAITING_EVENT_PAYMENT_TOKEN_VALIDITY_TIME_OFFSET_SECONDS:10}

notificationRetry.eventOffsetSeconds=${NOTIFICATION_RETRY_EVENT_BASE_INTERVAL_SECONDS}
notificationRetry.maxAttempts=${NOTIFICATION_RETRY_EVENT_MAX_ATTEMPTS}

notificationsService.uri=${NOTIFICATIONS_SERVICE_URI}
notificationsService.readTimeout=${NOTIFICATIONS_SERVICE_READ_TIMEOUT}
notificationsService.connectionTimeout=${NOTIFICATIONS_SERVICE_CONNECTION_TIMEOUT}
notificationsService.apiKey=${NOTIFICATIONS_SERVICE_API_KEY}

transactionsService.uri=${TRANSACTIONS_SERVICE_URI}
transactionsService.readTimeout=${TRANSACTIONS_SERVICE_READ_TIMEOUT}
transactionsService.connectionTimeout=${TRANSACTIONS_SERVICE_CONNECTION_TIMEOUT}
transactionsService.apiKey=${TRANSACTIONS_SERVICE_API_KEY}

confidentialDataManager.personalDataVault.apiKey=${PERSONAL_DATA_VAULT_API_KEY}
confidentialDataManager.personalDataVault.apiBasePath=${PERSONAL_DATA_VAULT_API_BASE_PATH}

sendPaymentResult.timeoutSeconds=${SEND_PAYMENT_RESULT_TIMEOUT_SECONDS}
sendPaymentResult.expirationOffset=${SEND_PAYMENT_RESULT_EXPIRATION_OFFSET_SECONDS}

npg.uri=${NPG_URI}
npg.readTimeout=${NPG_READ_TIMEOUT}
npg.connectionTimeout=${NPG_CONNECTION_TIMEOUT}
npg.client.apiKey=${NPG_API_KEY}
npg.authorization.cards.keys=${NPG_CARDS_PSP_KEYS}
npg.authorization.cards.pspList=${NPG_CARDS_PSP_LIST}

redisStream.eventController.streamKey=${REDIS_STREAM_EVENT_CONTROLLER_STREAM_KEY}
redisStream.eventController.consumerGroupPrefix=${REDIS_STREAM_EVENT_CONTROLLER_CONSUMER_GROUP_PREFIX}
redisStream.eventController.consumerNamePrefix=${REDIS_STREAM_EVENT_CONTROLLER_CONSUMER_NAME_PREFIX}
redisStream.eventController.failOnErrorCreatingConsumerGroup=${REDIS_STREAM_EVENT_CONTROLLER_FAIL_ON_ERROR_CREATING_CONSUMER_GROUP:true}
eventController.status.pollingChron=${EVENT_CONTROLLER_STATUS_POLLING_CHRON}

spring.task.scheduling.pool.size=5